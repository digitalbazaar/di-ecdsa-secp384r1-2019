<!DOCTYPE html>
<html>
  <head>
    <title>ECDSA secpr1 Cryptosuite v2019</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='//www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        subtitle: "Achieving Data Integrity using ECDSA with NIST-compliant curves",
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus:           "CG-DRAFT",



        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName:            "di-ecdsa-secpr1-2019",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",


        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://digitalbazaar.github.io/di-ecdsa-secpr1-2019/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        //extraCSS:             ["spec.css", "prettify.css"],

        // editors, add as many as you like
        // only "name" is required
        editors: [{
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/"
        }],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        authors: [{
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/"
        }],

        // extend the bibliography entries
        //localBiblio: webpayments.localBiblio,

        // name of the WG
        wg:           "W3C Credentials Community Group",

        // URI of the public WG page
        wgURI:        "https://www.w3.org/community/credentials/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-credentials",

        otherLinks: [{
          key: "Source control",
          data: [{
            value: "https://github.com/digitalbazaar/di-ecdsa-secpr1-2019/",
            href: "https://github.com/digitalbazaar/di-ecdsa-secpr1-2019/"
          }]
        }, {
          key: "Issue Tracker",
          data: [{
            value: "https://github.com/digitalbazaar/di-ecdsa-secpr1-2019/issues/",
            href: "https://github.com/digitalbazaar/di-ecdsa-secpr1-2019/issues/"
          }]
        }],

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "",
        maxTocLevel: 4,
        /*preProcess: [ webpayments.preProcess ],
        alternateFormats: [ {uri: "diff-20111214.html", label: "diff to previous version"} ],
        */
        localBiblio:  {
          "RDF-DATASET-CANONICALIZATION": {
            title:    "RDF Dataset Canonicalization",
            href:     "https://json-ld.github.io/rdf-dataset-canonicalization/spec/",
            authors:  ["David Longley", "Manu Sporny"],
            status:   "Draft Community Group Report",
            publisher:  "JSON-LD Community Group"
          },
          "SECURITY-VOCABULARY": {
            title:    "Security Linked Data Vocabulary",
            href:     "https://web-payments.org/vocabs/security",
            authors:  ["Manu Sporny","David Longley"],
            status:   "Draft Community Group Report",
            publisher:  "Web Payments Community Group"
          },
          "DATA-INTEGRITY": {
            title:    "Data Integrity 1.0",
            href:     "https://w3c-ccg.github.io/data-integrity-spec/",
            authors:  ["David Longley", "Manu Sporny"],
            status:   "Draft Community Group Report",
            publisher:  "Credentials Community Group"
          },
          "FIPS-186-4": {
            title:    "FIPS PUB 186-4: Digital Signature Standard (DSS)",
            href:     "https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf",
            status:   "National Standard",
            publisher:  "U.S. Department of Commerce/National Institute of Standards and Technology"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
This specification describes the EcdsaSecp384r1Signature and
EcdsaSecp256r1Signature created in 2019 for the Data Integrity specification.
      </p>
    </section>

    <section id='sotd'>
      <p>
This is an experimental specification and is undergoing regular revisions. It
is not fit for production deployment.
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <p>
This specification describes the EcdsaSecp384r1Signature and
EcdsaSecp256r1Signature created in 2019 for the Data Integrity
[[DATA-INTEGRITY]] specification. It uses the RDF Dataset Canonicalization
Algorithm [[RDF-DATASET-CANONICALIZATION]] to transform the input document into
its canonical form. It uses one of two mechanisms to digest and sign: SHA-256
[[RFC6234]] as the <a>message digest algorithm</a> and ECDSA with Curve P-256
defined in [[FIPS-186-4]] as the <a>signature algorithm</a>, or SHA-384
[[RFC6234]] as the <a>message digest algorithm</a> and ECDSA with Curve P-384
defined in [[FIPS-186-4]] as the <a>signature algorithm</a>.
      </p>

      <section id="conformance"></section>

      <section>
        <h2>Terminology</h2>
        <p>
The following terms are used throughout this document:
        </p>

        <dl>
          <dt><dfn>signature suite</dfn></dt>
          <dd>
A specified set of cryptographic primitives typically consisting of
a canonicalization algorithm, a message digest algorithm, and a signature
algorithm that are bundled together by cryptographers for developers
for the purposes of safety and convenience.
          </dd>
          <dt><dfn>canonicalization algorithm</dfn></dt>
          <dd>
An algorithm that takes an input document that has more than one possible
representation and always transforms it into a canonical form. This process is
sometimes also called <em>normalization</em>.
          </dd>
          <dt><dfn>message digest algorithm</dfn></dt>
          <dd>
An algorithm that takes an input message and produces a cryptographic
output message that is often many orders of magnitude smaller than the
input message. These algorithms are often 1) very fast, 2)
non-reversible, 3) cause the output to change significantly when even one
bit of the input message changes, and 4) make it infeasible to find two
different inputs for the same output.
          </dd>
          <dt><dfn>signature algorithm</dfn></dt>
          <dd>
An algorithm that takes an input message and produces an output value where the
receiver of the message can mathematically verify that the message has not
been modified in transit and came from someone possessing a particular secret.
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Data Model</h2>
      <p>
This specification defines a data model for a number of key formats and
signature formats.
      </p>

      <section>
        <h2>Key Formats</h2>

        <p class="issue" title="Refer normatively to a Multikey specification">
This specification should not specify multikey formats. It should, instead,
point to a multikey registry and/or specification. Examples of these
sorts of documents include the DID Specification Registries for <a
href="https://w3c.github.io/did-spec-registries/#verification-method-types">
Verification Method Types</a>, the key types in the <a
href="https://ns.did.ai/suites/multikey-2021/v1/">
Multikey2021 JSON-LD Context</a>, and key definitions in the <a
href="https://w3c-ccg.github.io/security-vocab/">Security Vocabulary</a>.
Ideally, the specification that this one points to would define all possible
multikeys listed in the <a href="https://github.com/multiformats/multicodec/blob/master/table.csv">Multicodec Registry</a>
and define how to encode them as multibase values in fields such as
`publicKeyMultibase` and `secretKeyMultibase`. The referenced specification
should also include an extensbility mechanism and registry for new values as
they are added to the Multicodec Registry.
        </p>

        <p>
The following two key formats are defined by this specification:
        </p>

        <section>
          <h3>EcdsaSecp256r1VerificationKey2019</h3>
          <p>
A Curve P-256 compressed public key as defined in [[FIPS-186-4]]. The key MUST
contain a `type` set to `EcdsaSecp256r1VerificationKey2019`, `controller`, and
`publicKeyMultibase` value as defined by this specification.
          </p>
        </section>
        <section>
          <h3>EcdsaSecp384r1VerificationKey2019</h3>
          <p>
A Curve P-384 compressed public key. The key MUST contain a `type` set to
`EcdsaSecp384r1VerificationKey2019`, `controller`, and `publicKeyMultibase`
value as defined by this specification.
          </p>
        </section>

	      <section>
          <h2>Key Format Examples</h2>

          <p>
An encoded Curve P-384 public key:
          </p>

          <pre class="example highlight">
{
  "@context": ["https://w3id.org/security/suites/ecdsa-2019/v1"],
  "id": "did:example:123456789abcdefghi#keys-1",
  "type": "EcdsaSecp384r1VerificationKey2019",
  "controller": "did:example:123456789abcdefghi",
  "publicKeyMultibase" : "zsJV1eTDACogBS8FMj5vXSa51g1CY1y88DR2DGDwTsMTotTG
			  ELVH1XTEsFP8ok9q22ssAaqHN5fMgm1kweTABZZNRSc"
}
          </pre>

          <p class="issue"
            title="Avoid key format proliferation by using multikey header value">
The pattern that Data Integrity Verification Keys use presently leads to an
proliferation in key types and JSON-LD Contexts. This proliferation can be
avoided without any loss of the single-field precision benefits of a
multibase-encoded multicodec public key. The only downside for the approach
demonstrated below is the loss of human-readable key type information. It could
be argued that developers shouldn't be provided such affordances to ensure that
they do not meddle with the values. Software libraries would ensure that the
multicodec header information matches the expected header based on the
cryptosuite that is utilizing the key for verification. See the section on
<a href="#signature-format-examples"></a> for more information.
          </p>

          <pre class="example highlight" title="A Multibase-encoded Multicodec Curve P-384 public key">
{
  "@context": ["https://w3id.org/security/multikey/v1"],
  "id": "did:example:123456789abcdefghi#keys-1",
  "type": "MulticodecVerificationKey",
  "controller": "did:example:123456789abcdefghi",
  "publicKeyMultibase" : "zsJV1eTDACogBS8FMj5vXSa51g1CY1y88DR2DGDwTsMTotTG
			  ELVH1XTEsFP8ok9q22ssAaqHN5fMgm1kweTABZZNRSc"
}
          </pre>


      </section>
    </section>

    <section>
      <h2>Signature Formats</h2>

      <p>
The <a>signature suites</a> listed in this specification MUST be used in
conjunction with the signing and verification algorithms in the
Data Integrity [[DATA-INTEGRITY]] specification. The following two signature
formats are defined by this specification.
      </p>

      <section>
        <h3>EcdsaSecp256r1Signature2019</h3>
        <p>
A document that complies with the Data Integrity specification has been signed
with EcdsaSecp256r1Signature2019 when it contains a `proof` value, and that
value contains a `type` set to `EcdsaSecp256r1Signature2019`, a `proofPurpose`,
`verificationMethod`, and `proofValue`, as is defined by this specification.
        </p>

        <p>
The suite consists of the following algorithms:
        </p>

        <table class="simple">
          <thead>
            <th>Parameter</th>
            <th>Value</th>
            <th>Specification</th>
          </thead>
          <tbody>
            <tr>
              <td>canonicalizationAlgorithm</td>
              <td>https://w3id.org/security#GCA2015</td>
              <td>[[RDF-DATASET-CANONICALIZATION]]</td>
            </tr>
            <tr>
              <td>digestAlgorithm</td>
              <td>https://www.iana.org/assignments/cose/cose.xhtml#SHA-256</td>
              <td>[[RFC6234]]</td>
            </tr>
            <tr>
              <td>signatureAlgorithm</td>
              <td>https://www.iana.org/assignments/cose/cose.xhtml#P-256</a></td>
              <td>[[RFC8422]]</td>
            </tr>
          </tbody>
        </table>

    </section>

    <section>
      <h3>EcdsaSecp384r1Signature2019</h3>
      <p>
  A document that complies with the Data Integrity specification has been signed
  with EcdsaSecp384r1Signature2019 when it contains a `proof` value, and that
  value contains a `type` set to `EcdsaSecp384r1Signature2019`, a `proofPurpose`,
  `verificationMethod`, and `proofValue`, as is defined by this specification.
      </p>

      <p>
  The suite consists of the following algorithms:
      </p>

      <table class="simple">
        <thead>
          <th>Parameter</th>
          <th>Value</th>
          <th>Specification</th>
        </thead>
        <tbody>
          <tr>
            <td>canonicalizationAlgorithm</td>
            <td>https://w3id.org/security#GCA2015</td>
            <td>[[RDF-DATASET-CANONICALIZATION]]</td>
          </tr>
          <tr>
            <td>digestAlgorithm</td>
            <td>https://www.iana.org/assignments/cose/cose.xhtml#SHA-384</td>
            <td>[[RFC6234]]</td>
          </tr>
          <tr>
            <td>signatureAlgorithm</td>
            <td>https://www.iana.org/assignments/cose/cose.xhtml#P-384</a></td>
            <td>[[RFC8422]]</td>
          </tr>
        </tbody>

      </table>

    </section>

    <section>
      <h2>Signature Format Examples</h2>

      <p>
An data integrity digital signature using ECDSA with Curve P-384:
      </p>

      <pre class="example">
{
  "@context": ["https://w3id.org/security/suites/ecdsa-2019/v1"],
  "type": "EcdsaSecp384r1Signature2019",
  "created": "2022-01-29T20:35:38Z",
  "verificationMethod": "did:example:123456789abcdefghi#keys-1",
  "proofPurpose": "assertionMethod",
  "proofValue": "z2rb7doJxczUFBTdV5F5pehtbUXPDUgKVugZZ99jniVXCUpojJ9PqLYV
                 evMeB1gCyJ4HqpnTyQwaoRPWaD3afEZboXCBTdV5F5pehtbUXPDUgKVugUpoj"
}
      </pre>

      <p class="issue"
        title="Avoid signature format proliferation by using text-based suite value">
The pattern that Data Integrity Signatures use presently leads to an
proliferation in signature types and JSON-LD Contexts. This proliferation can be
avoided without any loss of the security characteristics of tightly binding  a
cryptography suite version to one or more acceptable public keys.  See
<a href="#key-format-examples"></a>  for more information on what the matching
<a href="#example-a-multibase-encoded-multicodec-curve-p-384-public-key">
MulticodecVerificationKey format</a> could look like. The following signature
suites are currently being contemplated: Eddsa2022, NistEcdsa2022,
KoblitzEcdsa2022, Pgp2022, GostDsa2022, Sm9Ibsa2022, and Jws2022.
      </p>

      <pre class="example" title="A DataIntegritySignature example using a NistEcdsa2019 Cryptosuite">
{
  "@context": ["https://w3id.org/security/data-integrity/v1"],
  "type": "DataIntegritySignature",
  "cryptosuite": "NistEcdsa2022",
  "created": "2021-11-29T20:35:38Z",
  "verificationMethod": "did:example:123456789abcdefghi#keys-1",
  "proofPurpose": "assertionMethod",
  "proofValue": "z2rb7doJxczUFBTdV5F5pehtbUXPDUgKVugZZ99jniVXCUpojJ9PqLYV
                 evMeB1gCyJ4HqpnTyQwaoRPWaD3afEZboXCBTdV5F5pehtbUXPDUgKVugUpoj"
}
      </pre>

    </section>

  </section>
</section>

    <section>
      <h2>Algorithms</h2>

      <p>
This signature suite uses ECDSA over Curve P-256 or Curve P-384 as described in
[[FIPS-186-4]]. The steps to construct and verify the digital signature are
defined below.
      <p>

      <section>
        <h3>Modifications to Signature Algorithm</h3>

        <p>
The <var>digital signature algorithm</var> takes <var>tbs</var>, a
<var>privateKey</var>, and <var>options</var> as inputs and produces a
<var>signatureValue</var> as output.
        </p>
        <ol class="algorithm">
          <li>
Take <var>tbs</var>, which is the cryptographic hash of the data to be signed, a
set of raw <var>privateKey</var> bytes, and an <var>options</var> dictionary as
input to the signature suite.
          </li>
          <li>
Perform the digital signature on <var>tbs</var> using the ECDSA digital
signature algorithm using the requested curve (either Curve P-256 or P-384), as
defined in [[FIPS-186-4]] and store the result as <var>signatureValue</var>.
          </li>
          <li>
Update <var>signatureValue</var> by multibase-encoding the value using the
the base58btc encoding.
          </li>
        </ol>

      </section>

    <section>
        <h3>Modifications to Signature Verification Algorithm</h3>

        <p>
The <var>digital signature algorithm</var> defined Signature Verification
Algorithm takes the value to be verified, <em>tbv</em>, the <em>public key</em>
to the signature algorithm and returns a boolean value.
        </p>
        <ol class="algorithm">
          <li>
Multibase decode <var>tbv</var> using the base58btc alphabet and store the
result in <var>rawSignature</var>.
          </li>
          <li>
Take <var>rawSignature</var> and perform the digital signature verification
algorithm associated with the provided <em>public key</em> as specified in
[[FIPS-186-4]]. If the result is a valid signature, return <code>true</code>,
otherwise return <code>false</code>.
          </li>
        </ol>

      </section>

    </section>

    <section>
      <h2>Security Considerations</h2>
      <p>
The following section describes security considerations that developers
implementing this specification should be aware of in order to create secure
software.
      </p>

      <section>
        <h3>Split Key Formats From Cryptosuites</h3>

        <p class=issue>
Ensuring that cryptographic suites are versioned and tightly scoped to a very
small set of possible key types and signature schemes (ideally one key type and
size and one signature output type) is a design goal for most Data Integrity
cryptographic suites. Historically, this has been done by defining both the
key type and the cryptographic suite that uses the key type in the same
specification. The downside of doing so, however, is that there might be a
proliferation of different key types in multikey that result in different
cryptosuites defining the same key material differently. For example, one
cryptosuite might use compressed Curve P-256 keys while another uses
uncompressed values. If that occurs, it will harm interoperability. It will be
important in the coming months to years to ensure that this does not happen
by fully defining the multikey format in a separate specification so
cryptosuite specifications, such as this one, can refer to the multikey
specification, thus reducing the chances of multikey type proliferation and
improving the chances of maximum interoperability for the multikey format.
        </p>

      </section>

<div class="issue">TODO: We need to add a complete list of security
considerations.</div>



    </section>

  </body>
</html>
